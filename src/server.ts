/**
 * Copyright (c) 2024 Discover Financial Services
*/
import express, { Request, Response, NextFunction } from "express";
import bodyParser from "body-parser";
import swaggerUi from "swagger-ui-express";
import "./controllers/index.js";
import { RegisterRoutes } from "./routes.js";
import { ValidateError } from "tsoa";
import * as ocr from "@discoverfinancial/fin-ocr-sdk";
import swaggerJson from "./swagger.json" with { type: "json" };

const log = ocr.Log.new("ocr-web", process.env.LOG_LEVEL);

export interface ServerArgs {
  port?: number;
}

export class Server {

  private logHttpResponseBody = process.env.LOG_HTTP_RESPONSE_BODY;
  private checkMgr: ocr.CheckMgr;

  public static async run(args: ServerArgs) {
    const checkMgr = await ocr.CheckMgr.getInstanceByEnv(process.env);
    const server = new Server(checkMgr);
    await server.run(args);
  }

  private constructor(checkMgr: ocr.CheckMgr) {
    this.checkMgr = checkMgr;
  }

  public async run(args?: ServerArgs) {
    args = args || {};
    log.debug("Starting")
    const app = express();
    // Add middleware
    //app.use(express.json());
    //app.use(express.urlencoded({ extended: true }));
    app.use(this.logger.bind(this));
    app.use(bodyParser.urlencoded({ parameterLimit: 100000, limit: '200mb', extended: true }));
    app.use(bodyParser.json({ limit: '200mb' }));
    app.use("/swagger", swaggerUi.serve, this.serveSwagger.bind(this));
    // Register routes generated by tsoa from the controllers
    RegisterRoutes(app);
    app.use(this.handleError.bind(this));
    const port = args.port || 8080;
    app.listen(port, () => {
      log.info(`Listening on port ${port}`);
    });
  }

  // Logger middleware
  private logger(req: Request, res: Response, next: NextFunction) {
    const self = this;
    const start = Date.now();
    const ctx = ocr.Context.obtain(undefined, this.checkMgr.ocr.cfg);
    (req as any).ctx = ctx;
    ctx.info(`Received request: ${req.method} ${req.originalUrl}`);
    ctx.debug(`Headers: ${JSON.stringify(req.headers)}`);
    const oldWrite = res.write;
    const oldEnd = res.end;
    const chunks: any = [];
    let contentType: string | undefined;
    function handleChunk(chunk: any) {
      if (self.logHttpResponseBody && chunk) {
        if (!contentType) {
          contentType = res.getHeader("content-type")?.toString();
        }
        if (!contentType?.startsWith("image")) {
          chunks.push(self.convertChunk(chunk));
        }
      }
    }
    res.write = function (chunk: any) {
      handleChunk(chunk);
      return oldWrite.apply(res, arguments as any);
    };
    (res as any).end = function (chunk: any) {
      const elapsed = Date.now() - start;
      ctx.info(`Sent response: ${res.statusCode} ${req.originalUrl} ${elapsed}ms`);
      handleChunk(chunk);
      if (chunks.length > 0) {
        const body = Buffer.concat(chunks).toString('utf8');
        ctx.debug(`Response body: ${body}`);
      }
      oldEnd.apply(res, arguments as any);
      ctx.release();
    };
    res.on("error", (err: any) => {
      ctx.warn(`Error from ${req.method} ${req.originalUrl}: ${JSON.stringify(err)}`);
    });
    next();
  }

  private convertChunk(chunk: any): any {
    if (typeof chunk === "string") {
      chunk = Buffer.from(chunk, "utf-8");
    }
    return chunk;
  }

  // Error handling middleware
  private handleError(err: any, req: Request, res: Response, next: NextFunction) {
    const ctx = (req as any).ctx || log;
    if (err instanceof ValidateError) {
      ctx.warn(`Caught validation error for ${req.path}: ${JSON.stringify(err.fields)}`);
      return res.status(422).json({
        code: 422,
        message: `Validation failed: ${JSON.stringify(err?.fields)}`,
      });
    }
    if (err) {
      const code = err.scode || 500;
      const message = err.stack || err.msg || err.message;
      ctx.warn(`Caught error for ${req.path} (${code}): ${message}`);
      return res.status(code).json({ code, message });
    }
    next();
  }

  // Swagger middleware
  private async serveSwagger(_req: Request, res: Response) {
    return res.send(swaggerUi.generateHTML(swaggerJson));
  }


}
